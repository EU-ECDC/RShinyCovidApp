# Import output files for each country (generated by the model)
list_output_IT <- readRDS("output_model_IT_total.RDS")
list_output_FR <- readRDS("output_model_FR.RDS")
list_output_CZ <- readRDS("output_model_CZ.RDS")

# Import functions to generate plots
source("function_shiny.R")
source("function_server.R")
# Define server logic 
shinyServer(function(input, output) {
    # Create empty reactivevalues object
    rv <- reactiveValues()
    
    ## Observe Events in Forecasts tab
    # If country entry changes in the Forecasts tab, change rv$list_output, rv$region, 
    # rv$country and rv$condition1
    observeEvent(input$country,{
        # Set rv$selected to NULL (may be changed later by clicking on the map)
        rv$selected <- NULL
        if(input$country == 1){
            # If country is France, update region, country and list_output
            rv$list_output <- list_output_FR
            rv$region <- rv$country <- "FR"
        } else if(input$country == 2){
            # If country is Czechia, update region, country and list_output
            rv$list_output <- list_output_CZ
            rv$region <- rv$country <- "CZ"
        } else if(input$country == 3){
            # If country is Italy, update region, country and list_output
            rv$list_output <- list_output_IT
            rv$region <- rv$country <- "IT"
            # Deactivate the "age" checkbox, and set it to "non age stratified", since 
            # local age stratified data is not available in Italy
            updateCheckboxInput(inputId = "age", value = FALSE)
            rv$age <- 0
            shinyjs::disable(id = "age")
        }
        if(input$country != 3){
            # If the selected country is not Italy, activate the "age" checkbox
            shinyjs::enable(id = "age")
        }
        # Define condition1, which in this tab corresponds to the date of prediction
        rv$condition1 <- as.numeric(max(rv$list_output$pred$conditions)) - input$prev * 7
        rv$map <- rv$list_output$map[rv$list_output$map$LEVL_CODE == 3,]
    })
    
    # If prev slider changes, update condition1
    observeEvent(input$prev, {
        rv$condition1 <- as.numeric(max(rv$list_output$pred$conditions)) - input$prev * 7
    })
    
    # In the age box is ticked, update rv$age, which will be used to update the time
    # series plot
    observeEvent(input$age, rv$age <- input$age)
    
    # If the user clicks on the map in the Forecasts tab, update rv$selected and 
    # rv$region to change the time-series plot
    observeEvent(input$map_click, {
        # Extract coordinates of clicked point
        coords <- input$map_click
        # Match to rv$list_output$map to identify the region clicked by the user
        clicked <- st_as_sf(sp::SpatialPoints(matrix(c(coords$lng, coords$lat),nrow = 1)))
        st_crs(clicked) <- st_crs(rv$map)
        region_click <- 
            st_intersection(clicked, rv$map)$key
        
        # If the user clicked outside the map, set region to country and selected to NULL
        if(length(region_click) > 0){
            rv$selected <- rv$region <- region_click
        } else {
            rv$region <- rv$country
            rv$selected <- NULL
        }
    })
    
    ## Change plots in Forecasts tab
    observe({
        # Generate the Leaflet map
        output$map <- renderLeaflet({
            leaflet_inc(pred = rv$list_output$pred, nuts = input$nuts,
                        map = rv$map, 
                        pop = rv$list_output$pop, condition = rv$condition1,
                        pop_age = rv$list_output$pop_age, quant = input$quant/100, 
                        region_selected = rv$selected)
        })
        
        # Generate the time-series plot
        output$preds <- renderPlot({
            generate_figure_ts(pred = rv$list_output$pred, map = rv$list_output$map, 
                               obs = rv$list_output$obs, nuts = input$nuts, age = rv$age, 
                               days = input$weeks * 7, prev = input$prev * 7, 
                               log = input$log, condition = rv$condition1, region = rv$region)
        })
        
    })
    
    
    ## Observe Events in Predictors tab
    # If country entry changes in the Predictors tab, change rv$list_output2, 
    # rv$reg_groups_nuts, and rv$map_group
    # rv$reg_groups_nuts and rv$map_group are used to match region to list_output$map
    observeEvent(input$country2,{
        if(input$country2 == 1){
            # If country is France, update list_output, map_group and reg_groups_nuts
            rv$list_output2 <- list_output_FR
            rv$map2 <- rv$list_output2$map[rv$list_output2$map$LEVL_CODE == 3,]
            rv$reg_groups_nuts <- substr(colnames(rv$list_output2$obs), 4, 6)
            rv$map_group <- substr(rv$map2$key, start = 4, stop = 6)
        } else if(input$country2 == 2){
            # If country is Czechia, update list_output, map_group and reg_groups_nuts
            rv$list_output2 <- list_output_CZ
            rv$map2 <- rv$list_output2$map[rv$list_output2$map$LEVL_CODE == 3,]
            rv$reg_groups_nuts <- substr(colnames(rv$list_output2$obs), 4, 4)
            rv$map_group <- substr(rv$map2$key, start = 4, stop = 4)
        } else if(input$country2 == 3){
            # If country is Italy, update list_output, map_group and reg_groups_nuts
            rv$list_output2 <- list_output_IT
            rv$map2 <- rv$list_output2$map[rv$list_output2$map$LEVL_CODE == 3,]
            rv$reg_groups_nuts <- substr(colnames(rv$list_output2$obs), 1, 4)
            rv$map_group <- substr(rv$map2$key, start = 1, stop = 4)
        }
        if(input$nuts2 == 2){
            rv$reg_groups_nuts <- sub("[.].*", "", colnames(rv$list_output2$obs))
            rv$map_group <- NULL
        } else 
            names(rv$map_group) <- rv$map2$key
        
    })
    
    # If the button input$type is changed, update rv$type_map, which will be 
    # used to generate the first map in Predictors tab
    observeEvent(input$type, {
        if(input$type == 1) rv$type_map <- "incidence"
        if(input$type == 2) rv$type_map <- "cases"
        if(input$type == 3) rv$type_map <- "changes"
    })
    
    # If the button input$type is changed, update rv$reg_groups_nuts and rv$map_group
    # these values depend on input$country. 
    observeEvent(input$nuts2, {
        # If nuts-2 is selected, the way to extract region names depends on the selected country
        if(input$nuts2 == 1){ 
            if(input$country2 == 1){
                rv$reg_groups_nuts <- substr(colnames(rv$list_output2$obs), 4, 6)
                rv$map_group <- substr(rv$map2$key, start = 4, stop = 6)
            } else if(input$country2 == 2){
                rv$reg_groups_nuts <- substr(colnames(rv$list_output2$obs), 4, 4)
                rv$map_group <- substr(rv$map2$key, start = 4, stop = 4)
            } else if(input$country2 == 3){
                rv$reg_groups_nuts <- substr(colnames(rv$list_output2$obs), 1, 4)
                rv$map_group <- substr(rv$map2$key, start = 1, stop = 4)
            }
            names(rv$map_group) <- rv$map2$key
        } else{
            # If nuts-3 is selected, remove age from column names and set map_group to NULL
            rv$reg_groups_nuts <- sub("[.].*", "", colnames(rv$list_output2$obs))
            rv$map_group <- NULL
        }
    })
    
    ## Change plots in Predictors tab
    observe({
        # First map depends on nuts level, and type selected
        output$map2 <- renderPlot({
            figure_inc(pred = rv$list_output2$pred, nuts = input$nuts2,
                       map = rv$map2, pop = rv$list_output2$pop,
                       pop_age = rv$list_output2$pop_age, obs = rv$list_output2$obs,
                       quant = input$quant2/100, type = rv$type_map)
        })
        # Plot subnational risks of secondary transmissions, and importations
        output$ar <- renderPlot({
            plot_predictor(predictor = rv$list_output2$predictors, group_reg = rv$reg_groups_nuts, 
                           map = rv$map2, pop = rv$list_output2$pop, 
                           pop_age = rv$list_output2$pop_age, group_map = rv$map_group, type = "ar")
        })
        output$en <- renderPlot({
            plot_predictor(predictor = rv$list_output2$predictors, group_reg = rv$reg_groups_nuts, 
                           map = rv$map2, pop = rv$list_output2$pop, 
                           pop_age = rv$list_output2$pop_age, group_map = rv$map_group, type = "en")
        })
        
    })
    
    
    ## Observe Events in Scenarios tab
    # If country entry changes in the Scenarios tab, change rv$list_output3, 
    # rv$region3, rv$country3
    observeEvent(input$country3,{
        # Set rv$selected2 to NULL (may be changed later by clicking on the map)
        rv$selected2 <- NULL
        if(input$country3 == 1){
            # If country is France, update region3, country3 and list_output3
            rv$list_output3 <- list_output_FR
            rv$region3 <- rv$country3 <- "FR"
        } else if(input$country3 == 2){
            # If country is Czechia, update region3, country3 and list_output3
            rv$list_output3 <- list_output_CZ
            rv$region3 <- rv$country3 <- "CZ"
        } else if(input$country3 == 3){
            # If country is Italy, update region3, country3 and list_output3
            rv$list_output3 <- list_output_IT
            rv$region3 <- rv$country3 <- "IT"
            # Deactivate the "age2" checkbox and "target" button, 
            # and set them to "non age stratified" and "Everyone", since 
            # local age stratified data is not available in Italy
            updateRadioButtons(inputId = "target", selected = 1)
            updateCheckboxInput(inputId = "age2", value = FALSE)
            rv$target <- "all"
            rv$age2 <- 0
            # Update condition2, which in this tab corresponds to the current 
            # combination of transmi, NPI, target, and delay tabs 
            rv$condition2 <- paste(1 + input$transmi/100, 1 - input$NPI/100,
                                   rv$target, as.numeric(input$delay) * 7, sep = ";")
            shinyjs::disable(id = "age2")
            shinyjs::disable(id = "target")
        }
        if (input$country3 != 3 & input$import == 0){
            # If the selected country is not Italy, activate the "age2" checkbox 
            # and "target" button
            shinyjs::enable(id = "age2")
            shinyjs::enable(id = "target")
        }
        rv$map3 <- rv$list_output3$map[rv$list_output3$map$LEVL_CODE == 3,]
    })
    
    # In the age box is ticked, update rv$age2, which will be used to update the time
    # series plot
    observeEvent(input$age2, rv$age2 <- input$age2)
    
    # If the sliders "NPI" and "transmi", or the button "delay" are changed, then
    # update rv$condition2, which corresponds to the scenario chosen by the user
    observeEvent(eventExpr = {
        input$NPI
        input$transmi
        input$delay
    }, rv$condition2 <- paste(1 + input$transmi/100, 1 - input$NPI/100,
                              rv$target, as.numeric(input$delay) * 7, sep = ";")
    )
    
    # If the "import" box is ticked, update rv$target to "endemic", disable
    # the target button, and update rv$condition2
    observeEvent(input$import,{
        if(input$import){ 
            rv$target <- "endemic"
            updateRadioButtons(inputId = "target", selected = 1)
            shinyjs::disable(id = "target")
        } else if(input$country3 != 3){
            # if the import box is unticked, and the country is not Italy, activate
            # the target button, and set target to "all"
            shinyjs::enable(id = "target")
            rv$target <- "all"
        } else rv$target <- "all"
        rv$condition2 <- paste(1 + input$transmi/100, 1 - input$NPI/100, 
                               rv$target, as.numeric(input$delay) * 7, sep = ";")
    })
    
    # If the target button is changed, update rv$target and rv$condition2
    observeEvent(input$target, {
        if(input$import == 0){
            rv$target <- "all"
            if(input$target == 2){ rv$target <- "children"
            } else if(input$target == 3){ rv$target <- "work"
            } else if(input$target == 4){ rv$target <- "older"
            }
        }
        rv$condition2 <- paste(1 + input$transmi/100, 1 - input$NPI/100, 
                               rv$target, as.numeric(input$delay) * 7, sep = ";")
    })
    
    # If the user clicks on the map in the Scenarios tab, update rv$selected and
    # rv$region to change the time-series plot
    observeEvent(input$map3_click, {
        isolate({
            # Extract coordinates of clicked point
            coords <- input$map3_click
            # Match to rv$list_output$map to identify the region clicked by the user
            clicked <- st_as_sf(sp::SpatialPoints(matrix(c(coords$lng, coords$lat), nrow = 1)))
            st_crs(clicked) <- st_crs(rv$map3)
            region_click <- st_intersection(clicked, rv$map3)$key
            # If the user clicked outside the map, set region to country and selected to NULL
            if(length(region_click) > 0) rv$selected2 <- rv$region3 <- region_click else{
                rv$region3 <- rv$country3
                rv$selected2 <- NULL
            }
        })
    })
    
    ## Change plots in Scenarios tab
    observe({
        # Generate the Leaflet map
        output$map3 <- renderLeaflet({
            leaflet_inc(pred = rv$list_output3$scenario, nuts = input$nuts3,
                        map = rv$map3, pop = rv$list_output3$pop, 
                        condition = rv$condition2, pop_age = rv$list_output3$pop_age, 
                        quant = input$quant3/100, region_selected = rv$selected2)
        })
        
        # Generate the time-series plot
        output$preds2 <- renderPlot({
            generate_figure_ts(pred = rv$list_output3$scenario, map = rv$list_output3$map, 
                               obs = rv$list_output3$obs, nuts = input$nuts3, 
                               age = rv$age2, days = input$weeks2 * 7, prev = 0, 
                               log = input$log2, condition = rv$condition2, region = rv$region3)
        })
    })
})
