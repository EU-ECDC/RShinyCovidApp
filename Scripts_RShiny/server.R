# Import output files for each country (generated by the model)
list_output_IT <- readRDS("output_model_IT_total.RDS")
list_output_FR <- readRDS("output_model_FR.RDS")
list_output_CZ <- readRDS("output_model_CZ.RDS")

calib <- readRDS("all_calib_countries.rds")

# Import functions to generate plots
source("function_shiny.R")
source("function_server.R")
# Define server logic 
shinyServer(function(input, output) {
    # Create empty reactivevalues object
    rv <- reactiveValues()
    rv$new_country <- 1
    rv$new_country2 <- 1
    rv$new_country3 <- 1
    
    ## Observe Events in Forecasts tab
    # If country entry changes in the Forecasts tab, change rv$list_output, rv$region, 
    # rv$country and rv$condition1
    observeEvent(input$country,{
        # Set rv$selected to NULL (may be changed later by clicking on the map)
        rv$selected <- NULL
        rv$new_country <- 1
        if(input$country == 1){
            # If country is France, update region, country and list_output
            rv$list_output <- list_output_FR
            rv$region <- rv$country <- "FR"
        } else if(input$country == 2){
            # If country is Czechia, update region, country and list_output
            rv$list_output <- list_output_CZ
            rv$region <- rv$country <- "CZ"
        } else if(input$country == 3){
            # If country is Italy, update region, country and list_output
            rv$list_output <- list_output_IT
            rv$region <- rv$country <- "IT"
            # Deactivate the "age" checkbox, and set it to "non age stratified", since 
            # local age stratified data is not available in Italy
            updateCheckboxInput(inputId = "age", value = FALSE)
            rv$age <- 0
            shinyjs::disable(id = "age")
        }
        if(input$type == 2){
          # Deactivate the "nuts" checkbox, and set it to "nuts 2 (coarse)", since 
          # nuts3 death data is not available
          updateRadioButtons(inputId = "nuts", selected = 1)
          rv$nuts <- 1
          shinyjs::disable(id = "nuts")              
        } else{
          # otherwise activate the "nuts" button
          shinyjs::enable(id = "nuts")
        }
        
        if(input$country != 3){
            # If the selected country is not Italy, activate the "age" checkbox
            shinyjs::enable(id = "age")
        }
        # Define condition1, which corresponds to the date of prediction in this tab
        rv$condition1 <- max(as.numeric(rv$list_output$pred$conditions)) - input$prev * 7
        # Define the variables map and max_obs
        rv$map <- rv$list_output$map[rv$list_output$map$LEVL_CODE == 3,]
        rv$max_obs <- as.Date(max(epoch(rv$list_output$obs)), origin = "1970-01-01")
        # Add data_death to list_output$obs
        rv$list_output$obs <- list(rv$list_output$obs, rv$list_output$data_death)
    })
    
    # If type changes, update nuts
    observeEvent(input$type, {
      if(input$type == 2){
        # Deactivate the "nuts" checkbox, and set it to "nuts 2 (coarse)", since 
        # nuts3 death data is not available in Italy
        updateRadioButtons(inputId = "nuts", selected = 1)
        rv$nuts <- "1"
        shinyjs::disable(id = "nuts")
      } else{
        # However, activate the "nuts" button
        shinyjs::enable(id = "nuts")
      }
    })
    
    # If prev slider changes, update condition1
    observeEvent(input$prev, {
        rv$condition1 <- max(as.numeric(rv$list_output$pred$conditions)) - input$prev * 7
    })
    
    # In the age box is ticked, update rv$age, which will be used to update the time
    # series plot
    observeEvent(input$age, rv$age <- input$age)
    
    # In the nuts changes, update rv$nuts, which will be used to update the time
    # series plot and the map
    observeEvent(input$nuts, rv$nuts <- input$nuts)
    
    # If the user clicks on the map in the Forecasts tab, update rv$selected and 
    # rv$region to change the time-series plot
    observeEvent(input$map_click, {
        rv$new_country <- 0
        # Extract coordinates of clicked point
        coords <- input$map_click
        # Match to rv$list_output$map to identify the region clicked by the user
        clicked <- st_as_sf(sp::SpatialPoints(matrix(c(coords$lng, coords$lat),nrow = 1)))
        st_crs(clicked) <- st_crs(rv$map)
        region_click <- 
            st_intersection(clicked, rv$map)$key
        
        # If the user clicked outside the map, set region to country and selected to NULL
        if(length(region_click) > 0){
            rv$selected <- rv$region <- region_click
        } else {
            rv$region <- rv$country
            rv$selected <- NULL
        }
    })
    
    ## Change plots in Forecasts tab
    observe({
        # Generate the Leaflet map
        output$map <- renderLeaflet({
            leaflet_inc(pred = rv$list_output$pred, nuts = rv$nuts,
                        map = rv$map, type = input$type,
                        pop = rv$list_output$pop, condition = rv$condition1,
                        pop_age = rv$list_output$pop_age, quant = input$quant/100, 
                        region_selected = rv$selected)
        })
        
        # Generate the time-series plot
        if(rv$new_country == 0){
          output$preds <- renderPlot({
            generate_figure_ts(pred = rv$list_output$pred, map = rv$list_output$map, 
                               obs = rv$list_output$obs, max_obs = rv$max_obs, 
                               nuts = rv$nuts, age = rv$age, days = input$weeks * 7, 
                               prev = input$prev * 7, type = input$type, log = input$log, 
                               condition = rv$condition1, region = rv$region)
          })
        } else{
          output$preds <- renderPlot({
            plot.new()
            mtext(paste0(strwrap("Click on the map to plot local forecasts; click outside the map to move back to national level forecasts"), collapse = "\n"), 
                  at = 0.5)
          })
        }
        
    })
    
    
    ## Observe Events in Predictors tab
    # If country entry changes in the Predictors tab, change rv$list_output2, 
    # rv$reg_groups_nuts, and rv$map_group
    # rv$reg_groups_nuts and rv$map_group are used to match region to list_output$map
    observeEvent(input$country2,{
        if(input$country2 == 1){
            # If country is France, update list_output, map_group and reg_groups_nuts
            rv$list_output2 <- list_output_FR
            rv$map2 <- rv$list_output2$map[rv$list_output2$map$LEVL_CODE == 3,]
            rv$reg_groups_nuts <- substr(colnames(rv$list_output2$obs), 4, 6)
            rv$map_group <- substr(rv$map2$key, start = 4, stop = 6)
        } else if(input$country2 == 2){
            # If country is Czechia, update list_output, map_group and reg_groups_nuts
            rv$list_output2 <- list_output_CZ
            rv$map2 <- rv$list_output2$map[rv$list_output2$map$LEVL_CODE == 3,]
            rv$reg_groups_nuts <- substr(colnames(rv$list_output2$obs), 4, 4)
            rv$map_group <- substr(rv$map2$key, start = 4, stop = 4)
        } else if(input$country2 == 3){
            # If country is Italy, update list_output, map_group and reg_groups_nuts
            rv$list_output2 <- list_output_IT
            rv$map2 <- rv$list_output2$map[rv$list_output2$map$LEVL_CODE == 3,]
            rv$reg_groups_nuts <- substr(colnames(rv$list_output2$obs), 1, 4)
            rv$map_group <- substr(rv$map2$key, start = 1, stop = 4)
        }
        if(input$nuts2 == 2){
            rv$reg_groups_nuts <- sub("[.].*", "", colnames(rv$list_output2$obs))
            rv$map_group <- NULL
        } else 
            names(rv$map_group) <- rv$map2$key
        
    })
    
    # If the button input$type_map is changed, update rv$type_map, which will be 
    # used to generate the first map in Predictors tab
    observeEvent(input$type_map, {
        if(input$type_map == 1) rv$type_map <- "incidence"
        if(input$type_map == 2) rv$type_map <- "cases"
        if(input$type_map == 3) rv$type_map <- "changes"
    })
    
    # If the button input$type is changed, update rv$reg_groups_nuts and rv$map_group
    # these values depend on input$country. 
    observeEvent(input$nuts2, {
        # If nuts-2 is selected, the way to extract region names depends on the selected country
        if(input$nuts2 == 1){ 
            if(input$country2 == 1){
                rv$reg_groups_nuts <- substr(colnames(rv$list_output2$obs), 4, 6)
                rv$map_group <- substr(rv$map2$key, start = 4, stop = 6)
            } else if(input$country2 == 2){
                rv$reg_groups_nuts <- substr(colnames(rv$list_output2$obs), 4, 4)
                rv$map_group <- substr(rv$map2$key, start = 4, stop = 4)
            } else if(input$country2 == 3){
                rv$reg_groups_nuts <- substr(colnames(rv$list_output2$obs), 1, 4)
                rv$map_group <- substr(rv$map2$key, start = 1, stop = 4)
            }
            names(rv$map_group) <- rv$map2$key
        } else{
            # If nuts-3 is selected, remove age from column names and set map_group to NULL
            rv$reg_groups_nuts <- sub("[.].*", "", colnames(rv$list_output2$obs))
            rv$map_group <- NULL
        }
    })
    
    ## Change plots in Predictors tab
    observe({
        # First map depends on nuts level, and type selected
        output$map2 <- renderPlot({
            figure_inc(pred = rv$list_output2$pred, nuts = input$nuts2,
                       map = rv$map2, pop = rv$list_output2$pop,
                       pop_age = rv$list_output2$pop_age, obs = rv$list_output2$obs,
                       quant = input$quant2/100, type = rv$type_map)
        })
        # Plot subnational risks of secondary transmissions, and importations
        output$ar <- renderPlot({
            plot_predictor(predictor = rv$list_output2$predictors, group_reg = rv$reg_groups_nuts, 
                           map = rv$map2, pop = rv$list_output2$pop, 
                           pop_age = rv$list_output2$pop_age, group_map = rv$map_group, type = "ar")
        })
        output$en <- renderPlot({
            plot_predictor(predictor = rv$list_output2$predictors, group_reg = rv$reg_groups_nuts, 
                           map = rv$map2, pop = rv$list_output2$pop, 
                           pop_age = rv$list_output2$pop_age, group_map = rv$map_group, type = "en")
        })
        
    })
    
    
    ## Observe Events in Scenarios tab
    # If country entry changes in the Scenarios tab, change rv$list_output3, 
    # rv$region3, rv$country3
    observeEvent(input$country3,{
        # Set rv$selected2 to NULL (may be changed later by clicking on the map)
        rv$selected2 <- NULL
        
        rv$new_country2 <- 1
        if(input$country3 == 1){
            # If country is France, update region3, country3 and list_output3
            rv$list_output3 <- list_output_FR
            rv$region3 <- rv$country3 <- "FR"
        } else if(input$country3 == 2){
            # If country is Czechia, update region3, country3 and list_output3
            rv$list_output3 <- list_output_CZ
            rv$region3 <- rv$country3 <- "CZ"
        } else if(input$country3 == 3){
            # If country is Italy, update region3, country3 and list_output3
            rv$list_output3 <- list_output_IT
            rv$region3 <- rv$country3 <- "IT"
            # Deactivate the "age2" checkbox and "target" button, 
            # and set them to "non age stratified" and "Everyone", since 
            # local age stratified data is not available in Italy
            updateRadioButtons(inputId = "target", selected = 1)
            updateCheckboxInput(inputId = "age2", value = FALSE)
            rv$target <- "all"
            rv$age2 <- 0
            # Update condition2, which in this tab corresponds to the current 
            # combination of transmi, NPI, target, and delay tabs 
            rv$condition2 <- paste(1 + input$transmi/100, 1 - input$NPI/100,
                                   rv$target, as.numeric(input$delay) * 7, sep = ";")
            shinyjs::disable(id = "age2")
            shinyjs::disable(id = "target")
        }
        if (input$country3 != 3 & input$import == 0){
            # If the selected country is not Italy, activate the "age2" checkbox 
            # and "target" button
            shinyjs::enable(id = "age2")
            shinyjs::enable(id = "target")
        }
        if(input$type3 == 2){
          # Deactivate the "nuts" checkbox, and set it to "nuts 2 (coarse)", since 
          # nuts3 death data is not available
          updateRadioButtons(inputId = "nuts3", selected = 1)
          rv$nuts <- 1
          shinyjs::disable(id = "nuts3")
        } else{
          # Otherwise, activate the "nuts" button
          shinyjs::enable(id = "nuts3")
        }
        
        # Define the variables map3 and max_obs3
        rv$map3 <- rv$list_output3$map[rv$list_output3$map$LEVL_CODE == 3,]
        rv$max_obs3 <- as.Date(max(epoch(rv$list_output3$obs)), origin = "1970-01-01")
        # Add data_death to list_output3$obs
        rv$list_output3$obs <- list(rv$list_output3$obs, rv$list_output3$data_death)
    })
    
    # If type changes, update nuts
    observeEvent(input$type3, {
      if(input$type3 == 2){
        # Deactivate the "nuts" checkbox, and set it to "nuts 2 (coarse)", since 
        # nuts3 death data is not available in Italy
        updateRadioButtons(inputId = "nuts3", selected = 1)
        rv$nuts3 <- "1"
        shinyjs::disable(id = "nuts3")
      } else{
        # Otherwise, activate the "nuts" button
        shinyjs::enable(id = "nuts3")
      }
    })
    
    # In the nuts changes, update rv$nuts3, which will be used to update the time
    # series plot and the map
    observeEvent(input$nuts3, rv$nuts3 <- input$nuts3)
    
    # In the age box is ticked, update rv$age2, which will be used to update the time
    # series plot
    observeEvent(input$age2, rv$age2 <- input$age2)
    
    # If the sliders "NPI" and "transmi", or the button "delay" are changed, then
    # update rv$condition2, which corresponds to the scenario chosen by the user
    observeEvent(eventExpr = {
        input$NPI
        input$transmi
        input$delay
    }, rv$condition2 <- paste(1 + input$transmi/100, 1 - input$NPI/100,
                              rv$target, as.numeric(input$delay) * 7, sep = ";")
    )
    
    # If the "import" box is ticked, update rv$target to "endemic", disable
    # the target button, and update rv$condition2
    observeEvent(input$import,{
        if(input$import){ 
            rv$target <- "endemic"
            updateRadioButtons(inputId = "target", selected = 1)
            shinyjs::disable(id = "target")
        } else if(input$country3 != 3){
            # if the import box is unticked, and the country is not Italy, activate
            # the target button, and set target to "all"
            shinyjs::enable(id = "target")
            rv$target <- "all"
        } else rv$target <- "all"
        rv$condition2 <- paste(1 + input$transmi/100, 1 - input$NPI/100, 
                               rv$target, as.numeric(input$delay) * 7, sep = ";")
    })
    
    # If the target button is changed, update rv$target and rv$condition2
    observeEvent(input$target, {
        if(input$import == 0){
            rv$target <- "all"
            if(input$target == 2){ rv$target <- "children"
            } else if(input$target == 3){ rv$target <- "work"
            } else if(input$target == 4){ rv$target <- "older"
            }
        }
        rv$condition2 <- paste(1 + input$transmi/100, 1 - input$NPI/100, 
                               rv$target, as.numeric(input$delay) * 7, sep = ";")
    })
    
    # If the user clicks on the map in the Scenarios tab, update rv$selected and
    # rv$region to change the time-series plot
    observeEvent(input$map3_click, {
        rv$new_country2 <- 0
        
        isolate({
            # Extract coordinates of clicked point
            coords <- input$map3_click
            # Match to rv$list_output$map to identify the region clicked by the user
            clicked <- st_as_sf(sp::SpatialPoints(matrix(c(coords$lng, coords$lat), nrow = 1)))
            st_crs(clicked) <- st_crs(rv$map3)
            region_click <- st_intersection(clicked, rv$map3)$key
            # If the user clicked outside the map, set region to country and selected to NULL
            if(length(region_click) > 0) rv$selected2 <- rv$region3 <- region_click else{
                rv$region3 <- rv$country3
                rv$selected2 <- NULL
            }
        })
    })
    
    ## Change plots in Scenarios tab
    observe({
        # Generate the Leaflet map
        output$map3 <- renderLeaflet({
            leaflet_inc(pred = rv$list_output3$scenario, nuts = rv$nuts3,
                        map = rv$map3, pop = rv$list_output3$pop, type = input$type3,
                        condition = rv$condition2, pop_age = rv$list_output3$pop_age, 
                        quant = input$quant3/100, region_selected = rv$selected2)
        })
        
        # Generate the time-series plot
        if(rv$new_country2 == 0){
          output$preds2 <- renderPlot({
            generate_figure_ts(pred = rv$list_output3$scenario, max_obs = rv$max_obs3, map = rv$list_output3$map, 
                               obs = rv$list_output3$obs, nuts = rv$nuts3, type = input$type3,
                               age = rv$age2, days = input$weeks2 * 7, prev = 0, 
                               log = input$log2, condition = rv$condition2, region = rv$region3)
          })
        } else{
          output$preds2 <- renderPlot({
            plot.new()
            mtext(paste0(strwrap("Click on the map to plot local forecasts; click outside the map to move back to national level forecasts"), collapse = "\n"), 
                  at = 0.5)
          })
        }
    })
    
    
    
    
    ## Observe Events in replicate paper tab
    # If country entry changes in the replicate paper tab, change rv$list_output4, 
    # rv$region4, rv$country4
    observeEvent(input$country4,{
      # Set rv$selected3 to NULL (may be changed later by clicking on the map)
      rv$selected3 <- NULL
      
      rv$new_country3 <- 1
      if(input$country4 == 1){
        # If country is France, update region3, country3 and list_output3
        rv$list_output4 <- calib[[3]]
        rv$region4 <- rv$country4 <- "FR"
        rv$map4 <- list_output_FR$map[list_output_FR$map$LEVL_CODE == 3,]
        rv$pop <- list_output_FR$pop
        rv$pop_age <- list_output_FR$pop_age
        shinyjs::enable(id = "age3")
        # updateCheckboxInput(inputId = "age3", value = TRUE)
        # rv$age3 <- 1
        # shinyjs::disable(id = "age3")
      } else if(input$country4 == 2){
        # If country is Czechia, update region3, country3 and list_output3
        rv$list_output4 <- calib[[2]]
        rv$region4 <- rv$country4 <- "CZ"
        rv$map4 <- list_output_CZ$map[list_output_CZ$map$LEVL_CODE == 3,]
        rv$pop <- list_output_CZ$pop
        rv$pop_age <- list_output_CZ$pop_age
        shinyjs::enable(id = "age3")
        # updateCheckboxInput(inputId = "age3", value = TRUE)
        # rv$age3 <- 1
        # shinyjs::disable(id = "age3")
      } else if(input$country4 == 3){
        # If country is Italy, update region3, country3 and list_output3
        rv$list_output4 <- calib[[1]]
        rv$region4 <- rv$country4 <- "IT"
        # Deactivate the "age2" checkbox and "target" button, 
        # and set them to "non age stratified" and "Everyone", since 
        # local age stratified data is not available in Italy
        updateCheckboxInput(inputId = "age3", value = FALSE)
        rv$age3 <- 0
        shinyjs::disable(id = "age3")
        rv$map4 <- list_output_IT$map[list_output_IT$map$LEVL_CODE == 3,]
        rv$pop <- list_output_IT$pop
        rv$pop_age <- list_output_IT$pop_age
        
      }
      if(input$type4 == 2){
        # Deactivate the "nuts" checkbox, and set it to "nuts 2 (coarse)", since 
        # nuts4 death data is not available
        updateRadioButtons(inputId = "nuts4", selected = 1)
        rv$nuts4 <- 1
        shinyjs::disable(id = "nuts4")
      } else{
        updateRadioButtons(inputId = "nuts4", selected = 2)
        rv$nuts4 <- "2"
        shinyjs::disable(id = "nuts4")
      }
    })
    
    # If type changes, update nuts
    observeEvent(input$type4, {
      if(input$type4 == 2){
        # Deactivate the "nuts" checkbox, and set it to "nuts 2 (coarse)", since 
        # nuts3 death data is not available in Italy
        updateRadioButtons(inputId = "nuts4", selected = 1)
        rv$nuts4 <- "1"
        shinyjs::disable(id = "nuts")
      } else{
        # However, activate the "nuts" button
        updateRadioButtons(inputId = "nuts4", selected = 2)
        rv$nuts4 <- "2"
      }
    })
    
    # In the age box is ticked, update rv$age, which will be used to update the time
    # series plot
    observeEvent(input$age3, rv$age3 <- input$age3)
    
    # In the nuts changes, update rv$nuts, which will be used to update the time
    # series plot and the map
    observeEvent(input$nuts4, rv$nuts4 <- input$nuts4)
    
    # If the user clicks on the map in the replicate paper tab, update rv$selected and 
    # rv$region to change the time-series plot
    observeEvent(input$map4_click, {
      rv$new_country3 <- 0
      # Extract coordinates of clicked point
      coords <- input$map4_click
      # Match to rv$list_output$map to identify the region clicked by the user
      clicked <- st_as_sf(sp::SpatialPoints(matrix(c(coords$lng, coords$lat),nrow = 1)))
      st_crs(clicked) <- st_crs(rv$map4)
      region_click <- 
        st_intersection(clicked, rv$map4)$key
      
      # If the user clicked outside the map, set region to country and selected to NULL
      if(length(region_click) > 0){
        rv$selected3 <- rv$region4 <- region_click
      } else {
        rv$region4 <- rv$country4
        rv$selected3 <- NULL
      }
    })
    
    ## Change plots in replicate paper tab
    observe({
      # Generate the Leaflet map
      output$map4 <- renderLeaflet({
        leaflet_old(calib = rv$list_output4, nuts = rv$nuts4,
                    map = rv$map4, type = input$type4, pop = rv$pop, 
                    pop_age = rv$pop_age, n_week = input$n_week, 
                    region_selected = rv$selected3)
      })
      
      # Generate the time-series plot
      if(rv$new_country3 == 0){
        output$preds3 <- renderPlot({
          generate_ts_old(calib = rv$list_output4, max_obs = rv$max_obs4, map = rv$map4,
                          nuts = rv$nuts4, age = rv$age3, n_week = input$n_week,
                          type = input$type4, log = input$log3, region = rv$region4)
        })
      } else{
        output$preds3 <- renderPlot({
          plot.new()
          mtext(paste0(strwrap("Click on the map to plot local forecasts; click outside the map to move back to national level forecasts"), collapse = "\n"), 
                at = 0.5)
        })
      }
      
    })
    
    
})
